/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include "main.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif








#define I2C_SCL_SPEED_SM 	100000
#define HSI_SPEED			8000000

#define I2C_READY 					0
#define I2C_BUSY_IN_RX 				1
#define I2C_BUSY_IN_TX 			2

#define DS1307_DEVICE_ADDR		0x68

#define DS1307_ADDR_SEC 		0x00
#define DS1307_ADDR_MIN 		0x01
#define DS1307_ADDR_HRS			0x02
#define DS1307_ADDR_DAY			0x03
#define DS1307_ADDR_DATE		0x04
#define DS1307_ADDR_MONTH		0x05
#define DS1307_ADDR_YEAR		0x06



#define TIME_FORMAT_12HRS_AM 	0
#define TIME_FORMAT_12HRS_PM 	1
#define TIME_FORMAT_24HRS 		2

#define SUNDAY  	1;
#define MONDAY  	2;
#define TUESDAY  	3;
#define WEDNESDAY   4;
#define THURSDAY  	5;
#define FRIDAY  	6;
#define SATURDAY  	7;

#define ALARM_CLOCK_NO_ALARM		0
#define ALARM_CLOCK_ALARM			1
#define ALARM_CLOCK_SET				2
#define ALARM_CLOCK_SET_ALARM		3



typedef struct
{
	uint8_t seconds;
	uint8_t minutes;
	uint8_t hours;
	uint8_t time_format;
}RTC_time_t;


uint8_t *pBuffer;
uint32_t len;
uint8_t repeatedStart;
uint8_t I2C_state = I2C_READY;
uint8_t tx[2];
uint8_t data;
uint8_t loadedData;
uint8_t alarmClockState;
uint8_t alarmClockSetNum;
uint8_t timeSet = 0;


RTC_time_t current_time;


uint8_t binary_to_bcd(uint8_t value)
{
	//Ones is bit 0:3, tens is bit 4:6
	uint8_t tens, ones,bcd;
	//If only 1s bcd value is the same as binary
	bcd = value;
	if(value >= 10)
	{
		tens = value/10;
		ones = value %10;
		bcd = (uint8_t)((tens<<4)|ones );
	}
	return bcd;
}

uint8_t bcd_to_binary(uint8_t value)
{
	//Ones is bit 0:3, tens is bit 4:6
	//This function gets the amount of tens and ones
	uint8_t tens, ones,binary;
	tens = (value >>4);
	ones = (value & 0x0F);
	binary = tens*10 + ones;

	return (uint8_t)binary;
}



uint8_t  I2C_RXTX_Start(uint8_t * pTXBuffer, uint32_t Len, uint8_t sr,uint8_t RXTX,uint8_t value,uint8_t reg_addr)
{
	//Check if the state isnt busy recieving or transmitting
	if( (I2C_state != I2C_BUSY_IN_TX) && (I2C_state != I2C_BUSY_IN_RX))
	{
		tx[0]=reg_addr;
			tx[1] = value;
		//Set the I2C state and other global vars
		I2C_state = RXTX;
		pBuffer = pTXBuffer;
		len = Len;
		repeatedStart = sr;

		if(I2C_state == I2C_BUSY_IN_RX)
		{
			//Addtionally acking should be enabled if recieving
			I2C1->CR1 |= (1<< 10);
		}


		//Generate START Condition
		I2C1->CR1 |= (1<< 8);

		//Implement the code to enable ITBUFEN Control Bit
		I2C1->CR2 |= ( 1 << 10);

		//Implement the code to enable ITEVFEN Control Bit
		I2C1->CR2 |= ( 1 << 9);

		//Implement the code to enable ITERREN Control Bit
		I2C1->CR2 |= ( 1 << 8);

		return I2C_READY;


	}
	return I2C_state;
}

static void ds1307_write(uint8_t value,uint8_t reg_addr)
{
	//Sends two bytes of data to enable the clock


	while(I2C_RXTX_Start(tx, 2, 0,I2C_BUSY_IN_TX,value,reg_addr) != I2C_READY);
}

void ds1307_read(uint8_t reg_addr)
{

	//Data will be read from current position of pointer so data write is used to set pointer position
	while(I2C_RXTX_Start(&reg_addr, 1, 1,I2C_BUSY_IN_TX,0,0)  != I2C_READY);
	while(I2C_RXTX_Start(&data, 1, 0,I2C_BUSY_IN_RX,0,0) != I2C_READY);

}

#define NVIC_ISER0		0xE000E100
#define NVIC_ISER1		0xE000E104





void ds1307_set_current_time(RTC_time_t *rtc_time)
{
	uint8_t seconds, hrs;
	seconds = binary_to_bcd(rtc_time->seconds);
	//Ensure bit 7 is cleared to not turn of clock
	seconds &= ~(1<<7);
	ds1307_write(seconds,DS1307_ADDR_SEC);

	//send minutes
	ds1307_write(binary_to_bcd(rtc_time->minutes),DS1307_ADDR_MIN);

	//set hours
	hrs = binary_to_bcd(rtc_time->hours);
	//Ensure bit 7 is cleared to not turn of clock
	if(rtc_time->time_format == TIME_FORMAT_24HRS)
	{
		hrs &= ~(1 << 6);
	}
	else
	{
		hrs |= (1 << 6);
		hrs =(rtc_time->time_format ==TIME_FORMAT_12HRS_PM ) ? hrs | (1<<5) : hrs & ~(1<<5);
	}
	ds1307_write(hrs,DS1307_ADDR_HRS);
}
void ds1307_get_current_time(RTC_time_t *rtc_time)
{
	uint8_t seconds,hrs;
	ds1307_read(DS1307_ADDR_SEC);
	for(int k = 0; k < 1000; k++)
	{
		;
	}
	seconds = loadedData;
	seconds &= ~(1 << 7);

	rtc_time->seconds = bcd_to_binary(seconds);
	ds1307_read(DS1307_ADDR_MIN);
	for(int k = 0; k < 1000; k++)
		{
			;
		}
	rtc_time->minutes = bcd_to_binary(loadedData);

	ds1307_read(DS1307_ADDR_HRS);
	for(int k = 0; k < 1000; k++)
		{
			;
		}
	hrs = loadedData;
	if(hrs & (1<<6))
	{
		//12hr format
		//ever gives 12hr am (0) or 12hr pm (1)
		rtc_time->time_format = !((hrs & (1<< 5)) == 0) ;
		//clear 6th and 5th position
		hrs &= ~(0x3 << 5);
	}
	else
	{
		//24hrs format
		rtc_time->time_format = TIME_FORMAT_24HRS;
	}

	rtc_time->hours = bcd_to_binary(hrs);
}


void updateSetTime(RTC_time_t *rtc_time)
{
	uint8_t tens, ones;
	//Tens hours
	if(alarmClockSetNum == 0)
	{
		rtc_time->hours += 10;
		if(rtc_time->hours > 12)
		{
			rtc_time->hours %= 10;
		}
		else
		{
			rtc_time->hours %= 20;
		}

	}
	//One hours
	else if(alarmClockSetNum == 1)
	{
		tens = rtc_time->hours / 10;
		ones = (rtc_time->hours) %10;
		if(tens == 1)
		{
			ones = ((ones+1)% 3);
		}
		else if (tens == 0)
		{
			ones = ((ones+1)% 10);
			if(ones == 0) ones = 1;
		}

		rtc_time->hours = (tens*10 + ones);

	}
	//Tens minutes
	else if(alarmClockSetNum == 2)
	{
		tens = rtc_time->minutes / 10;
		ones = rtc_time->minutes % 10;
		tens += 1;
		tens %= 6;
		rtc_time->minutes = (tens*10 + ones);
	}
	//ones minutes
	else if(alarmClockSetNum == 3)
	{
		tens = rtc_time->minutes / 10;
		ones = (rtc_time->minutes +1) % 10;

		rtc_time->minutes = (tens*10 + ones);
	}
	else if(alarmClockSetNum == 4)
	{
		if(rtc_time->time_format == TIME_FORMAT_12HRS_PM)
		{
			rtc_time->time_format = TIME_FORMAT_12HRS_AM;
		}
		else if(rtc_time->time_format == TIME_FORMAT_12HRS_AM)
		{
			rtc_time->time_format = TIME_FORMAT_12HRS_PM;
		}
	}
	timeSet = 1;
}

RTC_time_t current_time;
RTC_time_t alarm_time;
uint32_t buttonModeProcessed = 0, buttonModeLastDebounceTime = 0;
uint32_t buttonSetProcessed = 0, buttonSetLastDebounceTime = 0;




int main(void)
{


    /* Loop forever */
	uint32_t *RCC_APB2ENR = (uint32_t *)(0x40021018);
	uint32_t *RCC_APB1ENR = (uint32_t *)(0x4002101C);
	uint32_t *AFIO_EXTICR1 =  (uint32_t *)(0x40010008);
	uint32_t *EXTI_IMR =  (uint32_t *)(0x40010400);
	uint32_t *EXTI_RTSR =  (uint32_t *)(0x40010408);


	//Enable clock on GPIOA, GPIOB, GPIOC AFIO,TIM1,TIM2,TIM3,TIM4 and I2C1
	*RCC_APB2ENR |= (1 << 2);
	*RCC_APB2ENR |= (1 << 3);
	*RCC_APB2ENR |= (1 << 4);
	*RCC_APB2ENR |= (1 << 0);
	*RCC_APB2ENR |= (1<< 11);
	*RCC_APB1ENR |= (1<< 0);
	*RCC_APB1ENR |= (1<< 1);
	*RCC_APB1ENR |= (1<< 2);
	*RCC_APB1ENR |= (1<< 21);


	//Enable interupts for I2C for both event and error I2C and EXTI lines 0 and 1
	*((uint32_t*)NVIC_ISER0) |= 1<<6;
	*((uint32_t*)NVIC_ISER0) |= 1<<7;
	*((uint32_t*)NVIC_ISER0) |= 1<<29;
	*((uint32_t*)NVIC_ISER0) |= 1<<30;
	*((uint32_t*)NVIC_ISER0) |= 1<<31;
	*((uint32_t*)NVIC_ISER1) |= 1<<0;

	//Set the GPIOA ports to work for LEDS
	LED_Initalize();


	void (*NUM_4_SET)(void) = &LED_NUM_4_SET_4;

	(*NUM_4_SET)();


	//Setup the pins for the buttons and the alarm LED

	//B0 for mode button and B1 for set button
	//Set the Configuration to Input Pulldown
	GPIOB->CRL &= ~(0xF << 0);
	GPIOB->CRL |= (0x8 << 0);
	GPIOB->CRL &= ~(0xF << 4);
	GPIOB->CRL |= (0x8 << 4);

	//Configure AFIO line so EXTI0 is on Port B
	*AFIO_EXTICR1 |= (1<< 0);
	*AFIO_EXTICR1 |= (1<< 4);

	//Configure the EXTI by demasking the line and setting the trigger on rising edge
	*EXTI_IMR |= (1<< 0);
	*EXTI_RTSR |= (1<< 0);
	*EXTI_IMR |= (1<< 1);
	*EXTI_RTSR |= (1<< 1);

	//Configure the timer that handles long / short press

	//Set the PSC value
	TIM1->PSC |= (8000-1);
	TIM2->PSC |= (8000-1);
	TIM3->PSC |= (8000-1);
	TIM3->ARR = (4000-1);
	TIM3->DIER |= 1;
	TIM4->PSC |= (8000-1);
		TIM4->ARR = (4000-1);
		TIM4->DIER |= 1;
		TIM4->CR1 |= 1 << 2;
	TIM3->CR1 |= 1 << 1;
	TIM3->CR1 |= 1 << 2;

	//Enable the timer
	TIM1->CR1 |= 1;
	TIM2->CR1 |= 1;
	TIM4->CR1 |= 1;

//	TIM3->CR1 |= 1;

	for(int i = 0; i < 10000; i++)
			{
				;
			}


	TIM3->SR = 0;
	TIM3->CR1 &= ~(1 << 1);

	//Configure the pins B8 and B9 for I2C -> both need to be AF and open drain value of 1101
	GPIOB->CRL &= ~(0xF << 24);
	GPIOB->CRL |= (0xD << 24);
	GPIOB->CRL &= ~(0xF << 28);
	GPIOB->CRL |= (0xD << 28);



	//Set the frequency of clock provided to cr2
	I2C1->CR2 |= ((HSI_SPEED/1000000));


	//Configure the device address will maybe do
	I2C1->OAR1 |= (0x61 << 1);

	//The 14th bit of the OAR1 register must always be mainted by software as 1
	I2C1->OAR1 |= (1<<14);

	//Set the CCR
	I2C1->CCR |= ((HSI_SPEED / (2*I2C_SCL_SPEED_SM)));

	//Set the trise value
	I2C1->TRISE =(((HSI_SPEED / 1000000) + 1) & 0x3F);

	//Enable the I2C
	I2C1->CR1 |= 1;


	I2C_state= I2C_READY;

	//Make clock halt = 0 in DS peripheal
	//ds1307_write(0x0, DS1307_ADDR_SEC);




	current_time.seconds = 34;
	current_time.hours = 8;
	current_time.minutes = 42;
	current_time.time_format = TIME_FORMAT_12HRS_PM;


	alarm_time.seconds = 0;
	alarm_time.minutes = 0;
	alarm_time.hours = 12;
	alarm_time.time_format = TIME_FORMAT_12HRS_PM;

	//ds1307_set_current_time(&current_time);


//	while(1)
//	{
////		TEMPORARLIY DISABLE THE FETCHING OF DATA FROM I2C
//
//		//Handle mode swithching of alarm clock
//		if(!(GPIOB->IDR & 1) && !buttonModeProcessed && ((TIM1->CNT - buttonModeLastDebounceTime) > 50) && buttonModeLastDebounceTime != 0)
//		{
//			//Process the button press
//			buttonModeProcessed = 1;
//			buttonModeLastDebounceTime = 0;
//
//			//Change the alarm clock state
//			alarmClockState ++;
//			alarmClockState %= 4;
//			alarmClockSetNum = 0;
//		}
//
//
//		//Handle setting of alarm clock
//		if(!(GPIOB->IDR & (1<<1)) && !buttonSetProcessed && buttonSetLastDebounceTime != 0)
//		{
//			//Check for long pulse
//			if((TIM2->CNT - buttonSetLastDebounceTime) > 750)
//			{
//				//Process the button press
//				buttonSetProcessed = 1;
//				buttonSetLastDebounceTime = 0;
//
//				//Change the selected number
//				alarmClockSetNum ++;
//				alarmClockSetNum %= 5;
//
//
//
//			}
//			//Check for short pulse
//			else if((TIM2->CNT - buttonSetLastDebounceTime) > 50)
//			{
//
//				if(alarmClockState == ALARM_CLOCK_SET)
//				{
//					updateSetTime(&current_time);
//				}
//				if(alarmClockState == ALARM_CLOCK_SET_ALARM)
//				{
//					updateSetTime(&alarm_time);
//				}
//
//
//
//				//Process the button press
//				buttonSetProcessed = 1;
//				buttonSetLastDebounceTime = 0;
//			}
//
//		}
//	}
//
//
}

void I2C1_EV_IRQHandler(void)
{
	//SB bit set
	if(I2C1->SR1 & 1)
	{
		//SB bit cleared by wirting slave address to DR

		//In case of TX
		 if(I2C_state == I2C_BUSY_IN_TX)
		 {
			//As writing bit 0 must be cleared
			I2C1->DR = ((DS1307_DEVICE_ADDR << 1) & ~1);
		 }
		 else
		 {
			 I2C1->DR = ((DS1307_DEVICE_ADDR << 1)  | 1);
		 }

	}


	//ADDR flag set
	 if(I2C1->SR1& (1<< 1))
	 {
		 //ADDR flag cleared by reading SR1 then SR2
		//Write first byte of data
		 uint32_t dummyread;
		 dummyread = I2C1->SR1;
		 dummyread = I2C1->SR2;
		 (void)dummyread;


		 //In case of RX
		 if(I2C_state == I2C_BUSY_IN_RX)
		 {
			 //ACKING MUST BE DISABLED HERE IN CASE
			 I2C1->CR1 &= ~(1<< 10);
			 //Generate stop condition
			 I2C1->CR1 |= (1<< 9);
		 }

	 }

	 //BTF set close communication
	 if(I2C1->SR1& (1<< 2))
	 {
		 //TXE should also be set
		 if(I2C1->SR1& (1<< 7))
		 {
			 //Len should also equal 0
			 if(len == 0)
			 {
				 //Generate the stop conidtion
				 I2C1->CR1 |= (1<< 9);

				 //Disable the interupts
				 //Implement the code to enable ITBUFEN Control Bit
				I2C1->CR2 &= ~( 1 << 10);

				//Implement the code to enable ITEVFEN Control Bit
				I2C1->CR2 &= ~( 1 << 9);

				//Implement the code to enable ITERREN Control Bit
				I2C1->CR2 &= ~( 1 << 8);

				I2C_state= I2C_READY;
			 }
		 }
	 }

	//TXE set
	if(I2C1->SR1& (1<< 7))
	{
		//write data into DR
		if(len > 0)
		{
			//1. load the data in to DR
			I2C1->DR = *(pBuffer);

			//2. decrement the TxLen
			len--;

			//3. Increment the buffer address
			pBuffer++;

		}
	}

	//RXNE set
	if(I2C1->SR1& (1<< 6))
	{
		//End of event

		//Read the data from the data register to clear the RXNE flag
		loadedData = I2C1->DR;
		//Implement the code to enable ITBUFEN Control Bit
						I2C1->CR2 &= ~( 1 << 10);

						//Implement the code to enable ITEVFEN Control Bit
						I2C1->CR2 &= ~( 1 << 9);

						//Implement the code to enable ITERREN Control Bit
						I2C1->CR2 &= ~( 1 << 8);

						I2C_state= I2C_READY;


	}


}

void EXTI0_IRQHandler(void)
{
	uint32_t *EXTI_PR =  (uint32_t *)(0x40010414);
	//Set debounce time
	buttonModeLastDebounceTime = TIM1->CNT;
	buttonModeProcessed = 0;
	//Clear interupt
	*EXTI_PR |= (1 << 0);

}

void EXTI1_IRQHandler(void)
{
	uint32_t *EXTI_PR =  (uint32_t *)(0x40010414);
	//Set debounce time
	buttonSetLastDebounceTime = TIM2->CNT;
	buttonSetProcessed = 0;
	//Clear interupt
	*EXTI_PR |= (1 << 1);
}

void TIM3_IRQHandler(void)
{
	//Check if time has been updated within last cycle if so new time should be set
	if((timeSet = 1) && (alarmClockState == ALARM_CLOCK_SET))
	{
		ds1307_set_current_time(&current_time);
		timeSet = 0;
	}
	//If not get the time data and store it
	else
	{
		//ds1307_get_current_time(&current_time);
	}

	//Handle alarm checking


	//Clear the interupt
	TIM3->SR = 0;
}

void TIM4_IRQHandler(void)
{
	TIM4->SR = 0;
}



