/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>


void delay(void)
{
	for(uint32_t i = 0; i < 50000/2; i++);
}
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

struct GPIO
{
	uint32_t CRL,CRH,IDR,ODR,BSSR,BRR,LCKR;
};

struct SPI
{
	uint32_t CR1, CR2, SR, DR, CRCPR, RX_CRC, TX_CRC;
};

struct TIM
{
	uint32_t CR1, CR2, RESERVED1, DIER, SR, EGR, RESERVED2,RESERVED3,RESERVED4,CNT,PSC,ARR;
};

#define GPIOA ((struct GPIO *) 0x40010800)
#define GPIOB ((struct GPIO *) 0x40010C00)
#define GPIOC ((struct GPIO *) 0x40011000)
#define SPI1 ((struct SPI *) 0x40013000)

#define DMA_BASE  0x40020000
#define DMA_CH3_OFFSET	0x28
#define DMA_CCR_OFFSET	0x08
#define DMA_CNDTR_OFFSET	0x0C
#define DMA_CPAR_OFFSET	0x10
#define DMA_CMAR_OFFSET	0x14


#define NUMBER_LED				1
#define LED_DATA_PACKET_SIZE	288
#define RESET_DATA_PACKET_SIZE	2400
#define LED_BUFFER_SIZE			((LED_DATA_PACKET_SIZE * NUMBER_LED) + RESET_DATA_PACKET_SIZE)/8

uint8_t sk6812_buffer[LED_BUFFER_SIZE];

void sk6812_fill_buffer(uint8_t led_no)
{
	//

}



//Color should be in GRB format
void sk6812_set_led(uint32_t color,uint8_t led_no)
{
	//Set base pointer to buffer
	//Each led takes up 36 bytes
	uint8_t * ptr = &sk6812_buffer[36 * (led_no-1)];


	//Color is 24 bits
	for(signed char bit = 23; bit >= 0; bit--)
	{
		//Check if bit is a 1 or 0
		if(color & (1 << bit))
		{
			//bit is a 1
			//Check if led can start row or should be on own row
			if(bit %2 == 1)
			{
				//own row
				//first 8 bits of a 1 is 11111100 in hex this is 0xFC
				*ptr = 0xFC;
				//increment the pointer
				ptr ++;
				//set the last 4 bits of the next value as 0000 which is 0 in hex we therefore dont need to do anything

			}
			else
			{
				//start on half row set first four bits which is 1111 or xF
				*ptr |= 0xF;
				ptr ++;
				//last 8 bits are 11000000 hex is 0xC0
				*ptr = 0xC0;
				ptr ++;

			}
		}
		else
		{
			//bit is a 1
			//Check if led can start row or should be on own row
			if(bit %2 == 1)
			{
				//own row
				//first 8 bits of a 1 is 11100000 in hex this is 0xFC
				*ptr = 0xE0;
				//increment the pointer
				ptr ++;
				//set the last 4 bits of the next value as 0000 which is 0 in hex we therefore dont need to do anything

			}
			else
			{
				//start on half row set first four bits which is 1110
				*ptr |= 0xE;
				ptr ++;
				//last 8 bits are 0000000 hex is 0 so we just increment pointer
				ptr ++;

			}
		}
	}
}


int main(void)
{
	//Clear the buffer and set all data inside of it to 0
	memset(sk6812_buffer, 0, LED_BUFFER_SIZE);

	sk6812_set_led(0xFFFFFF,1);
	sk6812_set_led(0x000000,2);
	sk6812_set_led(0x000000,3);






    /* Loop forever */
	uint32_t *RCC_APB2ENR = (uint32_t *)(0x40021018);
	uint32_t *RCC_APHBENR = (uint32_t *)(0x40021014);
	uint32_t *DMA_CH3_CCR = (uint32_t *)(DMA_BASE + DMA_CH3_OFFSET + DMA_CCR_OFFSET);
	uint32_t *DMA_CH3_CNDTR = (uint32_t *)(DMA_BASE + DMA_CH3_OFFSET + DMA_CNDTR_OFFSET);
	uint32_t *DMA_CH3_CPAR = (uint32_t *)(DMA_BASE + DMA_CH3_OFFSET + DMA_CPAR_OFFSET);
	uint32_t *DMA_CH3_CMAR = (uint32_t *)(DMA_BASE + DMA_CH3_OFFSET + DMA_CMAR_OFFSET);
	uint32_t *RCC_CR1 = (uint32_t *)(0x40021000);
	uint32_t *RCC_CFGR = (uint32_t *)(0x40021004);
	uint32_t *ISER = (uint32_t *)(0xE000E104);
//

	*ISER |= (1<< 3);
//	*RCC_APB2ENR |= (1 << 2);
//
//	//Set mode to alternate function push pull
//	GPIOA->CRL &= ~(0xF<<20);
//	GPIOA->CRL |= (0x3 <<20);
//	GPIOA->CRL &= ~(0xF<<28);
//	GPIOA->CRL |= (0x3 <<28);
//
//	GPIOA->ODR |= (1 << 7);
//	delay();
//	GPIOA->ODR &= ~(1 << 7);
//	delay();
//	GPIOA->ODR |= (1 << 7);
//		delay();
//		GPIOA->ODR &= ~(1 << 7);
//		delay();
//		GPIOA->ODR |= (1 << 7);
//			delay();
//			GPIOA->ODR &= ~(1 << 7);
//			delay();
//			while(1);







//	//Disable the PLL
	*RCC_CR1 &= ~(1<< 24);
//
//	//Configure and set the clock to PLL
	*RCC_CFGR |= (1 <<  18);
//	//turn on PLL
	*RCC_CR1 |= (3<< 24);
//
//	//set PLL as system clock
*RCC_CFGR |= (2 <<  0);



	char data[] = "HELLO WORLD\n";


	//Enable clock on GPIOA and SPI and DMA
	*RCC_APB2ENR |= (1 << 2);
	*RCC_APB2ENR |= (1 << 12);
	*RCC_APHBENR |= (1 << 0);


	//Configure SPI SCLK GPIO A Pin 5

	//Set mode to alternate function push pull
	GPIOA->CRL &= ~(0xF<<20);
	GPIOA->CRL |= (0xB <<20);
	GPIOA->CRL &= ~(0xF<<28);
	GPIOA->CRL |= (0xB <<28);

	//Set the BR bits
	//SPI1->CR1 |= (0x1 << 0);
	//Set CPOL and CPHA
	//SPI1->CR1 |= (1 << 1);
	//Left as default
	//Set the DFF
	//Left as default
	//Set the LSBFIRSt bit
	//Left as default

	//Set SSM = 1 and SSI and SSM
	SPI1->CR1 |= (1 << 9);
	SPI1->CR1 |= (1 << 8);

	//Enable SPITx DMA
	SPI1->CR2 |= (1 << 1);


	//Configure the DMA
	//SPITx is on DMA1 channel 3

	//Set the MSIZE and PSIZE to 16bit
	//*DMA_CH3_CCR |= (1<<10);
	//*DMA_CH3_CCR |= (1<<8);
	//Enable memory increment
	*DMA_CH3_CCR |= (1<<7);
	//Set data transfer mode to read from memory to perhipheal
	*DMA_CH3_CCR |= (1<<4);
	*DMA_CH3_CCR |= (1<<5);
	*DMA_CH3_CNDTR = LED_BUFFER_SIZE;
	*DMA_CH3_CPAR = 0x4001300C;
	*DMA_CH3_CMAR = (uint32_t)sk6812_buffer;

	//Enable the DMA
	*DMA_CH3_CCR |= (1 << 0);




	//Set the MSTRT and SPE bits
	SPI1->CR1 |= (1 << 2);
	SPI1->CR1 |= (1 << 6);







	while(1);

}






