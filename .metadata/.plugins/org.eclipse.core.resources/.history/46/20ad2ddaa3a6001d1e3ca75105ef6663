/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include "main.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif




//Global variables
uint8_t alarmClockState;
uint8_t alarmClockSetNum;
uint8_t userUpdatedTime = 0;
uint8_t blinked = LED_ON;


//All the numbers have functions to set the LEDs to display a specific number
//This array of function pointers stores the address of all of these functions
//This array can then be access then derefrenced to set the leds to dispaly a number
void(*NUM_1_SET[2])(void) = {LED_NUM_1_SET_0,LED_NUM_1_SET_1};
void(*NUM_2_SET[10])(void) = {LED_NUM_2_SET_0,LED_NUM_2_SET_1,LED_NUM_2_SET_2,LED_NUM_2_SET_3,LED_NUM_2_SET_4,LED_NUM_2_SET_5,LED_NUM_2_SET_6,LED_NUM_2_SET_7,LED_NUM_2_SET_8,LED_NUM_2_SET_9};
void(*NUM_3_SET[10])(void) = {LED_NUM_3_SET_0,LED_NUM_3_SET_1,LED_NUM_3_SET_2,LED_NUM_3_SET_3,LED_NUM_3_SET_4,LED_NUM_3_SET_5,LED_NUM_3_SET_6,LED_NUM_3_SET_7,LED_NUM_3_SET_8,LED_NUM_3_SET_9};
void(*NUM_4_SET[10])(void) = {LED_NUM_4_SET_0,LED_NUM_4_SET_1,LED_NUM_4_SET_2,LED_NUM_4_SET_3,LED_NUM_4_SET_4,LED_NUM_4_SET_5,LED_NUM_4_SET_6,LED_NUM_4_SET_7,LED_NUM_4_SET_8,LED_NUM_4_SET_9};


RTC_time_t current_time;
RTC_time_t alarm_time;
uint32_t buttonModeProcessed = 0, buttonModeLastDebounceTime = 0;
uint32_t buttonSetProcessed = 0, buttonSetLastDebounceTime = 0;









int main(void)
{


    /* Loop forever */
	uint32_t *RCC_APB2ENR = (uint32_t *)(0x40021018);
	uint32_t *RCC_APB1ENR = (uint32_t *)(0x4002101C);


	//Enable clock on GPIOA, GPIOB, GPIOC AFIO,TIM1,TIM2,TIM3,TIM4 and I2C1

	*RCC_APB2ENR |= (1 << 0);
	*RCC_APB2ENR |= (1 << 2);
	*RCC_APB2ENR |= (1 << 3);
	*RCC_APB2ENR |= (1 << 4);
	*RCC_APB2ENR |= (1<< 11);
	*RCC_APB1ENR |= (1<< 0);
	*RCC_APB1ENR |= (1<< 1);
	*RCC_APB1ENR |= (1<< 2);
	*RCC_APB1ENR |= (1<< 21);

	//Enable interupts for EXTI (button presses) and timers
	*((uint32_t*)NVIC_ISER0) |= 1<<6;
	*((uint32_t*)NVIC_ISER0) |= 1<<7;
	*((uint32_t*)NVIC_ISER0) |= 1<<29;
	*((uint32_t*)NVIC_ISER0) |= 1<<30;



	LED_Initalize();

//
//	LED_NUM_2_SET_0();
//	LED_NUM_2_SET_1();
//	LED_NUM_2_SET_2();
//	LED_NUM_2_SET_3();
//	LED_NUM_2_SET_4();
//	LED_NUM_2_SET_5();
//	LED_NUM_2_SET_6();
//	LED_NUM_2_SET_7();
//	LED_NUM_2_SET_8();
//	LED_NUM_2_SET_9();
//
	TIM4->PSC |= (8000-1);
	TIM4->ARR = (1000-1);
	TIM4->DIER |= 1;
	TIM4->CR1 |= 1 << 2;
	TIM4->CR1 |= 1;

	buttons_intalize();


	//Configure and intalize the i2c peripheal to send data
	I2C_initalize();


	//Make clock halt = 0 in DS peripheal
	ds1307_write(0x0, DS1307_ADDR_SEC);


	//Set the default values of the clock and alarm
	current_time.seconds = 0;
	current_time.minutes = 0;
	current_time.hours = 12;
	current_time.time_format = TIME_FORMAT_12HRS_PM;

	alarm_time.seconds = 0;
	alarm_time.minutes = 0;
	alarm_time.hours = 12;
	alarm_time.time_format = TIME_FORMAT_12HRS_PM;

	//Set user updated time to true so the values are passed into the rtc module
	userUpdatedTime = USER_UPDATED_TIME;


	//Enable the timer that controls the interaction between the mcu and the rtc
	TIM3->PSC |= (8000-1);
	TIM3->ARR = (40000-1);
	TIM3->DIER |= 1;
	TIM3->CR1 |= 1 << 2;
	TIM3->CR1 |= 1;






	while(1)
	{

		//Handle mode swithching of alarm clock
		if(!(GPIOB->IDR & 1) && !buttonModeProcessed && ((TIM1->CNT - buttonModeLastDebounceTime) > 50) && buttonModeLastDebounceTime != 0)
		{
			//Process the button press
			buttonModeProcessed = 1;
			buttonModeLastDebounceTime = 0;

			//Change the alarm clock state
			alarmClockState ++;
			alarmClockState %= 4;
			alarmClockSetNum = 0;
		}


		//Handle setting of alarm clock
		if(!(GPIOB->IDR & (1<<1)) && !buttonSetProcessed && buttonSetLastDebounceTime != 0)
		{
			//Check for long pulse
			if((TIM2->CNT - buttonSetLastDebounceTime) > 500)
			{
				//Process the button press
				buttonSetProcessed = 1;
				buttonSetLastDebounceTime = 0;

				//Change the selected number
				alarmClockSetNum ++;
				alarmClockSetNum %= 5;



			}
			//Check for short pulse
			else if((TIM2->CNT - buttonSetLastDebounceTime) > 50)
			{
				//Update time. Time variable updated is based on what is being set
				if(alarmClockState == ALARM_CLOCK_SET)
				{
					//Update time then set userupdatedtime vairable so that mcu knows to write new time value to rtc
					updateClockTime(&current_time, alarmClockSetNum);
					userUpdatedTime = USER_UPDATED_TIME;
				}
				if(alarmClockState == ALARM_CLOCK_SET_ALARM)
				{
					//Update the dispalyed alarm to reflect this change in time
					updateClockTime(&alarm_time, alarmClockSetNum);
					uint8_t hoursTen,hoursOne,minsTen,minsOne;
					hoursTen = alarm_time.hours / 10;
					hoursOne = alarm_time.hours % 10;
					minsTen = alarm_time.minutes / 10;
					minsOne = alarm_time.minutes % 10;

					//Set the LEDS to display the numbers
					(*NUM_1_SET[hoursTen])();
					(*NUM_2_SET[hoursOne])();
					(*NUM_3_SET[minsTen])();
					(*NUM_4_SET[minsOne])();

				}

				//Process the button press
				buttonSetProcessed = 1;
				buttonSetLastDebounceTime = 0;
			}

		}
	}


}


void EXTI0_IRQHandler(void)
{
	//Save timer state to use a comparison to determine press length
	buttonModeLastDebounceTime = TIM1->CNT;
	buttonModeProcessed = 0;
	//Clear the EXTI interupt
	uint32_t *EXTI_PR =  (uint32_t *)(0x40010414);
	*EXTI_PR |= (1 << 0);

}

void EXTI1_IRQHandler(void)
{
	//Save timer state to use a comparison to determine press length
	buttonSetLastDebounceTime = TIM2->CNT;
	buttonSetProcessed = 0;
	//Clear interupt
	uint32_t *EXTI_PR =  (uint32_t *)(0x40010414);
	*EXTI_PR |= (1 << 1);
}

void TIM3_IRQHandler(void)
{
	//Handle the interaction between rtc and mcu

	//First a check must be made if the user has changed the clock values between interactions.
	//If this is the case the mcu should write the changed value to the rtc.
	//If this change has not been made the user should read the time value from the rtc.

	if(userUpdatedTime == USER_UPDATED_TIME)
	{
		ds1307_set_current_time(&current_time);
		userUpdatedTime = USER_NOT_UPDATED_TIME;
	}
	else
	{
		ds1307_get_current_time(&current_time);


		//Update the displayed LEDs
		//We only need to do this in the case we are viewing the time
		if(alarmClockState == ALARM_CLOCK_NO_ALARM)
		{
			uint8_t hoursTen,hoursOne,minsTen,minsOne;
			hoursTen = current_time.hours / 10;
			hoursOne = current_time.hours % 10;
			minsTen = current_time.minutes / 10;
			minsOne = current_time.minutes % 10;

			//Set the LEDS to display the numbers
			(*NUM_1_SET[hoursTen])();
			(*NUM_2_SET[hoursOne])();
			(*NUM_3_SET[minsTen])();
			(*NUM_4_SET[minsOne])();
		}



	}

	//Handle the checking of alarms by comparing all time values between the two clocks
	if(alarmClockState == ALARM_CLOCK_ALARM && alarm_time.hours == current_time.hours && alarm_time.minutes == current_time.minutes && alarm_time.time_format == current_time.time_format)
	{
		//Handle the alarm
	}

	//Clear the interupt
	TIM3->SR = 0;
}

void TIM4_IRQHandler(void)
{
	//When a user is editing the time of the clock or an alarm they must be able to know what number they are currently changing.
	//This timer toggles the current number on a set clock creating a blinking effect

	//Only blink if setting alarm or time
	if(alarmClockState == ALARM_CLOCK_SET || alarmClockState == ALARM_CLOCK_SET_ALARM)
	{
		if(blinked == LED_ON)
		{
			if(alarmClockSetNum == 0)
			{
				LED_NUM_1_CLEAR();
			}
			else if(alarmClockSetNum == 1)
			{
				LED_NUM_2_CLEAR();
			}
			else if(alarmClockSetNum == 2)
			{
				LED_NUM_3_CLEAR();
			}
			else if(alarmClockSetNum == 3)
			{
				LED_NUM_4_CLEAR();
			}

			//Now turn the led to off
			blinked = LED_OFF;
		}
		else
		{
			//Re dispaly the alarm time or the set time
			uint8_t hoursTen = 0
			uint8_t hoursOne = 0, minsTen = 0,minsOne = 0;

			if(alarmClockState == ALARM_CLOCK_SET)
			{
				hoursTen = current_time.hours / 10;
				hoursOne = current_time.hours % 10;
				minsTen = current_time.minutes / 10;
				minsOne = current_time.minutes % 10;
			}
			else
			{
				hoursTen = alarm_time.hours / 10;
				hoursOne = alarm_time.hours % 10;
				minsTen = alarm_time.minutes / 10;
				minsOne = alarm_time.minutes % 10;
			}
			if(alarmClockSetNum == 0)
			{

				(*NUM_1_SET[hoursTen])();
			}
			else if(alarmClockSetNum == 1)
			{
				uint8_t
				(*NUM_2_SET[hoursOne])();
			}
			else if(alarmClockSetNum == 2)
			{
				uint8_t
				(*NUM_3_SET[minsTen])();
			}
			else if(alarmClockSetNum == 3)
			{
				uint8_t
				(*NUM_4_SET[minsOne])();
			}

			//Turn the LED ON
			blinked = LED_ON;

		}
	}

	//Clear the SR
	TIM4->SR = 0;
}



