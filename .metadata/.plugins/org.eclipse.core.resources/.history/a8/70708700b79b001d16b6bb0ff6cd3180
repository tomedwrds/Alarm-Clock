/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>


void delay(void)
{
	for(uint32_t i = 0; i < 50000/2; i++);
}
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

struct GPIO
{
	uint32_t CRL,CRH,IDR,ODR,BSSR,BRR,LCKR;
};

struct SPI
{
	uint32_t CR1, CR2, SR, DR, CRCPR, RX_CRC, TX_CRC;
};

struct TIM
{
	uint32_t CR1, CR2, RESERVED1, DIER, SR, EGR, RESERVED2,RESERVED3,RESERVED4,CNT,PSC,ARR;
};

#define GPIOA ((struct GPIO *) 0x40010800)
#define GPIOB ((struct GPIO *) 0x40010C00)
#define GPIOC ((struct GPIO *) 0x40011000)
#define SPI1 ((struct SPI *) 0x40013000)

#define DMA_BASE  0x40020000
#define DMA_CH3_OFFSET	0x28
#define DMA_CCR_OFFSET	0x08
#define DMA_CNDTR_OFFSET	0x0C
#define DMA_CPAR_OFFSET	0x10
#define DMA_CMAR_OFFSET	0x14

int main(void)
{
//    /* Loop forever */
	uint32_t *RCC_APB2ENR = (uint32_t *)(0x40021018);
	uint32_t *RCC_APHBENR = (uint32_t *)(0x40021014);
	uint32_t *DMA_CH3_CCR = (uint32_t *)(DMA_BASE + DMA_CH3_OFFSET + DMA_CCR_OFFSET);
	uint32_t *DMA_CH3_CNDTR = (uint32_t *)(DMA_BASE + DMA_CH3_OFFSET + DMA_CNDTR_OFFSET);
	uint32_t *DMA_CH3_CPAR = (uint32_t *)(DMA_BASE + DMA_CH3_OFFSET + DMA_CPAR_OFFSET);
	uint32_t *DMA_CH3_CMAR = (uint32_t *)(DMA_BASE + DMA_CH3_OFFSET + DMA_CMAR_OFFSET);
	uint32_t *RCC_CR1 = (uint32_t *)(0x40021000);
	uint32_t *RCC_CFGR = (uint32_t *)(0x40021004);
	uint32_t *ISER = (uint32_t *)(0xE000E104);
//

	*ISER |= (1<< 3);
//	*RCC_APB2ENR |= (1 << 2);
//
//	//Set mode to alternate function push pull
//	GPIOA->CRL &= ~(0xF<<20);
//	GPIOA->CRL |= (0x3 <<20);
//	GPIOA->CRL &= ~(0xF<<28);
//	GPIOA->CRL |= (0x3 <<28);
//
//	GPIOA->ODR |= (1 << 7);
//	delay();
//	GPIOA->ODR &= ~(1 << 7);
//	delay();
//	GPIOA->ODR |= (1 << 7);
//		delay();
//		GPIOA->ODR &= ~(1 << 7);
//		delay();
//		GPIOA->ODR |= (1 << 7);
//			delay();
//			GPIOA->ODR &= ~(1 << 7);
//			delay();
//			while(1);







//	//Disable the PLL
//	*RCC_CR1 &= ~(1<< 24);
//
//	//Configure and set the clock to PLL
//	*RCC_CFGR |= (3 <<  18);
//	//turn on PLL
//	*RCC_CR1 |= (1<< 24);
//
//	//set PLL as system clock
//	*RCC_CFGR |= (2 <<  0);



	uint8_t data = 12646;


	//Enable clock on GPIOA and SPI and DMA
	*RCC_APB2ENR |= (1 << 2);
	*RCC_APB2ENR |= (1 << 12);
	*RCC_APHBENR |= (1 << 0);


	//Configure SPI SCLK GPIO A Pin 5

	//Set mode to alternate function push pull
	GPIOA->CRL &= ~(0xF<<20);
	GPIOA->CRL |= (0xB <<20);
	GPIOA->CRL &= ~(0xF<<28);
	GPIOA->CRL |= (0xB <<28);

	//Set the BR bits
	//SPI1->CR1 |= (0x1 << 0);
	//Set CPOL and CPHA
	//SPI1->CR1 |= (1 << 1);
	//Left as default
	//Set the DFF
	//Left as default
	//Set the LSBFIRSt bit
	//Left as default

	//Set SSM = 1 and SSI and SSM
	SPI1->CR1 |= (1 << 9);
	SPI1->CR1 |= (1 << 8);

	//Enable SPITx DMA
	SPI1->CR2 |= (1 << 1);


	//Configure the DMA
	//SPITx is on DMA1 channel 3

	//Set the MSIZE and PSIZE to 16bit
	//*DMA_CH3_CCR |= (1<<10);
	//*DMA_CH3_CCR |= (1<<8);
	//Enable memory increment
	*DMA_CH3_CCR |= (1<<7);
	//Set data transfer mode to read from memory to perhipheal
	*DMA_CH3_CCR |= (1<<4);
	*DMA_CH3_CNDTR = 1;
	*DMA_CH3_CPAR = 0x4001300C;
	*DMA_CH3_CMAR = (uint32_t)&data;

	//Enable the DMA
	*DMA_CH3_CCR |= (1 << 0);




	//Set the MSTRT and SPE bits
	SPI1->CR1 |= (1 << 2);
	SPI1->CR1 |= (1 << 6);


	while(1);

}






