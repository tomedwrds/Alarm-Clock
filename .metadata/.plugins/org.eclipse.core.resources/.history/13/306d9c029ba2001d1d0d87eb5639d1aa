/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

struct GPIO
{
	uint32_t CRL,CRH,IDR,ODR,BSSR,BRR,LCKR;
};

struct I2C
{
	uint32_t CR1, CR2, OAR1, OAR2, DR, SR1, SR2,CCR,TRISE;
};

#define GPIOA ((struct GPIO *) 0x40010800)
#define GPIOB ((struct GPIO *) 0x40010C00)
#define GPIOC ((struct GPIO *) 0x40011000)
#define I2C1 ((struct I2C *)   0x40005400)

#define LED_NUM_4_CLEAR() 		(GPIOA->ODR &= ~(127 << 0))
#define LED_NUM_4_0_ENABLE() 	(GPIOA->ODR |= 1)
#define LED_NUM_4_1_ENABLE() 	(GPIOA->ODR |= 1 << 1)
#define LED_NUM_4_2_ENABLE() 	(GPIOA->ODR |= 1 << 2)
#define LED_NUM_4_3_ENABLE() 	(GPIOA->ODR |= 1 << 3)
#define LED_NUM_4_4_ENABLE() 	(GPIOA->ODR |= 1 << 4)
#define LED_NUM_4_5_ENABLE() 	(GPIOA->ODR |= 1 << 5)
#define LED_NUM_4_6_ENABLE() 	(GPIOA->ODR |= 1 << 6)

#define LED_NUM_4_SET_0()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_4_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_1()		do{LED_NUM_4_CLEAR();LED_NUM_4_2_ENABLE();LED_NUM_4_5_ENABLE();} while(0);
#define LED_NUM_4_SET_2()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_4_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_3()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_4()		do{LED_NUM_4_CLEAR();LED_NUM_4_1_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_5_ENABLE();} while(0);
#define LED_NUM_4_SET_5()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_6()		do{LED_NUM_4_CLEAR();LED_NUM_4_6_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_4_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_7()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_5_ENABLE();} while(0);
#define LED_NUM_4_SET_8()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_4_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_9()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_5_ENABLE();} while(0);


#define I2C_SCL_SPEED_SM 	100000
#define HSI_SPEED			8000000

#define I2C_READY 					0
#define I2C_BUSY_IN_RX 				1
#define I2C_BUSY_IN_TX 				2

uint8_t *pTxBuffer;
uint32_t Len;
uint8_t SlaveAddr;
uint8_t Sr;
uint8_t I2C_state;






void  I2C_MasterSendDataIT(void)
{

	//Check if the state isnt busy recieving or transmitting
	if( (I2C_state != I2C_BUSY_IN_TX) && (I2C_state != I2C_BUSY_IN_RX))
	{
		//Generate START Condition
		I2C1->CR1 |= (1<< 8);


		//Implement the code to enable ITBUFEN Control Bit
		I2C1->CR2 |= ( 1 << 10);

		//Implement the code to enable ITEVFEN Control Bit
		I2C1->CR2 |= ( 1 << 9);

		//Implement the code to enable ITERREN Control Bit
		I2C1->CR2 |= ( 1 << 8);





	}



}


#define NVIC_ISER0		0xE000E100
#define NVIC_ISER1		0xE000E104



int main(void)
{


    /* Loop forever */
	uint32_t *RCC_APB2ENR = (uint32_t *)(0x40021018);
	uint32_t *RCC_APB1ENR = (uint32_t *)(0x4002101C);
	uint32_t *RCC_APHBENR = (uint32_t *)(0x40021014);


	//Enable clock on GPIOA, GPIOB and I2C1
	*RCC_APB2ENR |= (1 << 2);
	*RCC_APB2ENR |= (1 << 3);
	*RCC_APB1ENR |= (1<< 21);


	//Enable interupts for I2C for both event and error I2C 38 & 39
	*((uint32_t*)NVIC_ISER0) |= 1<<31;
	*((uint32_t*)NVIC_ISER1) |= 1<<0;

	//Set the GPIOA ports to work for LEDS
	uint32_t temp = 0;
	temp |= (1<< 0);
	temp |= (1<< 4);
	temp |= (1<< 8);
	temp |= (1<< 12);
	temp |= (1<< 16);
	temp |= (1<< 20);
	temp |= (1<< 24);
	GPIOA->CRL = temp;



	//Configure the pins B8 and B9 for I2C -> both need to be AF and open drain value of 1101
	GPIOB->CRL &= ~(0xF << 24);
	GPIOB->CRL |= (0xD << 24);
	GPIOB->CRL &= ~(0xF << 28);
	GPIOB->CRL |= (0xD << 28);


	//Set the frequency of clock provided to cr2
	I2C1->CR2 |= ((HSI_SPEED/1000000));


	//Configure the device address will maybe do
	I2C1->OAR1 |= (0x61 << 1);

	//The 14th bit of the OAR1 register must always be mainted by software as 1
	I2C1->OAR1 |= (1<<14);

	//Set the CCR
	I2C1->CCR |= ((HSI_SPEED / (2*I2C_SCL_SPEED_SM)));

	//Set the trise value
	I2C1->TRISE =(((HSI_SPEED / 1000000) + 1) & 0x3F);

	//Enable the I2C
	I2C1->CR1 |= 1;


	char data[] = "Hello world\n";
	pTxBuffer = data;
	Len = strlen(data);
	SlaveAddr = 0x68;
	Sr = 1;
	I2C_state = I2C_READY;

	I2C_MasterSendDataIT();

	while(1);

}

void I2C1_EV_IRQHandler(void)
{
	//SB bit set
	if(I2C1->SR1 & 1)
	{
		//SB bit cleared by wirting slave address to DR

		//As writing bit 0 must be cleared
		SlaveAddr = SlaveAddr <<1;
		I2C1->DR = (SlaveAddr & ~1);
	}


	//ADDR flag set
	 if(I2C1->SR1& (1<< 1))
	 {
		 //ADDR flag cleared by reading SR1 then SR2
		//Write first byte of data
		 uint32_t dummyread;
		 dummyread = I2C1->CR1;
		 dummyread = I2C1->CR2;
		 (void)dummyread;

	 }

	 //BTF set close communication
	 if(I2C1->SR1& (1<< 2))
	 {
		 //TXE should also be set
		 if(I2C1->SR1& (1<< 7))
		 {
			 //Len should also equal 0
			 if(Len == 0)
			 {
				 //Generate the stop conidtion
				 I2C1->CR1 |= (1<< 9);
			 }
		 }
	 }


	//TXE set
	if(I2C1->SR1& (1<< 7))
	{
		//write data into DR
		if(Len > 0)
		{
			//1. load the data in to DR
			I2C1->DR = *(pTxBuffer);

			//2. decrement the TxLen
			Len--;

			//3. Increment the buffer address
			pTxBuffer++;

		}
	}


}

void I2C1_ER_IRQHandler(void)
{

}






