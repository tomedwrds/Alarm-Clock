/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include "main.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif




//Global variables
uint8_t alarmClockState;
uint8_t alarmClockSetNum;
uint8_t timeSet = 0;
uint8_t blinked = 0;
void (*NUM_4_SET)(void) = &LED_NUM_4_SET_4;


RTC_time_t current_time;
RTC_time_t alarm_time;
uint32_t buttonModeProcessed = 0, buttonModeLastDebounceTime = 0;
uint32_t buttonSetProcessed = 0, buttonSetLastDebounceTime = 0;









int main(void)
{


    /* Loop forever */
	uint32_t *RCC_APB2ENR = (uint32_t *)(0x40021018);
	uint32_t *RCC_APB1ENR = (uint32_t *)(0x4002101C);


	//Enable clock on GPIOA, GPIOB, GPIOC AFIO,TIM1,TIM2,TIM3,TIM4 and I2C1

	*RCC_APB2ENR |= (1 << 0);
	*RCC_APB2ENR |= (1 << 2);
	*RCC_APB2ENR |= (1 << 3);
	*RCC_APB2ENR |= (1 << 4);
	*RCC_APB2ENR |= (1<< 11);
	*RCC_APB1ENR |= (1<< 0);
	*RCC_APB1ENR |= (1<< 1);
	*RCC_APB1ENR |= (1<< 2);
	*RCC_APB1ENR |= (1<< 21);

	//Enable interupts for EXTI (button presses) and timers
	*((uint32_t*)NVIC_ISER0) |= 1<<6;
	*((uint32_t*)NVIC_ISER0) |= 1<<7;
	*((uint32_t*)NVIC_ISER0) |= 1<<29;
	*((uint32_t*)NVIC_ISER0) |= 1<<30;



	LED_Initalize();

//
//	LED_NUM_2_SET_0();
//	LED_NUM_2_SET_1();
//	LED_NUM_2_SET_2();
//	LED_NUM_2_SET_3();
//	LED_NUM_2_SET_4();
//	LED_NUM_2_SET_5();
//	LED_NUM_2_SET_6();
//	LED_NUM_2_SET_7();
//	LED_NUM_2_SET_8();
//	LED_NUM_2_SET_9();
//


	buttons_intalize();


	TIM3->PSC |= (8000-1);
	TIM3->ARR = (4000-1);
	TIM3->DIER |= 1;
	TIM4->PSC |= (8000-1);
	TIM4->ARR = (1000-1);
	TIM4->DIER |= 1;
	TIM4->CR1 |= 1 << 2;
	TIM3->CR1 |= 1 << 1;
	TIM3->CR1 |= 1 << 2;


	//TIM4->CR1 |= 1;

//	TIM3->CR1 |= 1;



	TIM3->SR = 0;
	TIM3->CR1 &= ~(1 << 1);

	I2C_initalize();



	//Make clock halt = 0 in DS peripheal
	ds1307_write(0x0, DS1307_ADDR_SEC);




	current_time.seconds = 34;
	current_time.hours = 8;
	current_time.minutes = 42;
	current_time.time_format = TIME_FORMAT_12HRS_PM;


	alarm_time.seconds = 0;
	alarm_time.minutes = 0;
	alarm_time.hours = 12;
	alarm_time.time_format = TIME_FORMAT_12HRS_PM;

	ds1307_set_current_time(&current_time);



	while(1)
	{
//		TEMPORARLIY DISABLE THE FETCHING OF DATA FROM I2C

		//Handle mode swithching of alarm clock
		if(!(GPIOB->IDR & 1) && !buttonModeProcessed && ((TIM1->CNT - buttonModeLastDebounceTime) > 250) && buttonModeLastDebounceTime != 0)
		{
			//Process the button press
			buttonModeProcessed = 1;
			buttonModeLastDebounceTime = 0;

			//Change the alarm clock state
			alarmClockState ++;
			alarmClockState %= 4;
			alarmClockSetNum = 0;
		}


		//Handle setting of alarm clock
		if(!(GPIOB->IDR & (1<<1)) && !buttonSetProcessed && buttonSetLastDebounceTime != 0)
		{
			//Check for long pulse
			if((TIM2->CNT - buttonSetLastDebounceTime) > 750)
			{
				//Process the button press
				buttonSetProcessed = 1;
				buttonSetLastDebounceTime = 0;

				//Change the selected number
				alarmClockSetNum ++;
				alarmClockSetNum %= 5;



			}
			//Check for short pulse
			else if((TIM2->CNT - buttonSetLastDebounceTime) > 50)
			{

				if(alarmClockState == ALARM_CLOCK_SET)
				{
					updateSetTime(&current_time, &alarmClockSetNum, &timeSet);
				}
				if(alarmClockState == ALARM_CLOCK_SET_ALARM)
				{
					updateSetTime(&alarm_time, &alarmClockSetNum, &timeSet);
				}



				//Process the button press
				buttonSetProcessed = 1;
				buttonSetLastDebounceTime = 0;
			}

		}
	}


}


void EXTI0_IRQHandler(void)
{
	uint32_t *EXTI_PR =  (uint32_t *)(0x40010414);
	//Set debounce time
	buttonModeLastDebounceTime = TIM1->CNT;
	buttonModeProcessed = 0;
	//Clear interupt
	*EXTI_PR |= (1 << 0);

}

void EXTI1_IRQHandler(void)
{
	uint32_t *EXTI_PR =  (uint32_t *)(0x40010414);
	//Set debounce time
	buttonSetLastDebounceTime = TIM2->CNT;
	buttonSetProcessed = 0;
	//Clear interupt
	*EXTI_PR |= (1 << 1);
}

void TIM3_IRQHandler(void)
{
	//Check if time has been updated within last cycle if so new time should be set
	if((timeSet = 1) && (alarmClockState == ALARM_CLOCK_SET))
	{
		ds1307_set_current_time(&current_time);
		timeSet = 0;
	}
	//If not get the time data and store it
	else
	{
		//ds1307_get_current_time(&current_time);
	}

	//Handle alarm checking


	//Clear the interupt
	TIM3->SR = 0;
}

void TIM4_IRQHandler(void)
{
//	if(blinked == 0)
//	{
//		LED_NUM_4_CLEAR();
//
//	}
//	else
//	{
//
//		(*NUM_4_SET)();
//
//	}
//	blinked = !blinked;

	TIM4->SR = 0;
}



