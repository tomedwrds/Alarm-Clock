/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

struct GPIO
{
	uint32_t CRL,CRH,IDR,ODR,BSSR,BRR,LCKR;
};

struct I2C
{
	uint32_t CR1, CR2, OAR1, OAR2, DR, SR1, SR2,CCR,TRISE;
};

#define GPIOA ((struct GPIO *) 0x40010800)
#define GPIOB ((struct GPIO *) 0x40010C00)
#define GPIOC ((struct GPIO *) 0x40011000)
#define I2C1 ((struct I2C *)   0x40005400)

#define LED_NUM_4_CLEAR() 		(GPIOA->ODR &= ~(127 << 0))
#define LED_NUM_4_0_ENABLE() 	(GPIOA->ODR |= 1)
#define LED_NUM_4_1_ENABLE() 	(GPIOA->ODR |= 1 << 1)
#define LED_NUM_4_2_ENABLE() 	(GPIOA->ODR |= 1 << 2)
#define LED_NUM_4_3_ENABLE() 	(GPIOA->ODR |= 1 << 3)
#define LED_NUM_4_4_ENABLE() 	(GPIOA->ODR |= 1 << 4)
#define LED_NUM_4_5_ENABLE() 	(GPIOA->ODR |= 1 << 5)
#define LED_NUM_4_6_ENABLE() 	(GPIOA->ODR |= 1 << 6)

#define LED_NUM_4_SET_0()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_4_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_1()		do{LED_NUM_4_CLEAR();LED_NUM_4_2_ENABLE();LED_NUM_4_5_ENABLE();} while(0);
#define LED_NUM_4_SET_2()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_4_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_3()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_4()		do{LED_NUM_4_CLEAR();LED_NUM_4_1_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_5_ENABLE();} while(0);
#define LED_NUM_4_SET_5()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_6()		do{LED_NUM_4_CLEAR();LED_NUM_4_6_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_4_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_7()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_5_ENABLE();} while(0);
#define LED_NUM_4_SET_8()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_4_ENABLE();LED_NUM_4_5_ENABLE();LED_NUM_4_6_ENABLE();} while(0);
#define LED_NUM_4_SET_9()		do{LED_NUM_4_CLEAR();LED_NUM_4_0_ENABLE();LED_NUM_4_1_ENABLE();LED_NUM_4_2_ENABLE();LED_NUM_4_3_ENABLE();LED_NUM_4_5_ENABLE();} while(0);


#define I2C_SCL_SPEED_SM 	100000
#define HSI_SPEED			8000000

#define I2C_READY 					0
#define I2C_BUSY_IN_RX 				1
#define I2C_BUSY_IN_TX 			2

#define DS1307_DEVICE_ADDR		0x68

#define DS1307_ADDR_SEC 		0x00
#define DS1307_ADDR_MIN 		0x01
#define DS1307_ADDR_HRS			0x02
#define DS1307_ADDR_DAY			0x03
#define DS1307_ADDR_DATE		0x04
#define DS1307_ADDR_MONTH		0x05
#define DS1307_ADDR_YEAR		0x06



#define TIME_FORMAT_12HRS_AM 	0
#define TIME_FORMAT_12HRS_PM 	1
#define TIME_FORMAT_24HRS 		2

#define SUNDAY  	1;
#define MONDAY  	2;
#define TUESDAY  	3;
#define WEDNESDAY   4;
#define THURSDAY  	5;
#define FRIDAY  	6;
#define SATURDAY  	7;


typedef struct
{
	uint8_t date;
	uint8_t month;
	uint8_t year;
	uint8_t day;
}RTC_date_t;


typedef struct
{
	uint8_t seconds;
	uint8_t minutes;
	uint8_t hours;
	uint8_t time_format;
}RTC_time_t;


uint8_t *pBuffer;
uint32_t len;
uint8_t repeatedStart;
uint8_t I2C_state = I2C_READY;
uint8_t tx[2];
uint8_t data;



RTC_time_t current_time;
RTC_date_t current_date;


uint8_t binary_to_bcd(uint8_t value)
{
	//Ones is bit 0:3, tens is bit 4:6
	uint8_t tens, ones,bcd;
	//If only 1s bcd value is the same as binary
	bcd = value;
	if(value >= 10)
	{
		tens = value/10;
		ones = value %10;
		bcd = (uint8_t)((tens<<4)|ones );
	}
	return bcd;
}

uint8_t bcd_to_binary(uint8_t value)
{
	//Ones is bit 0:3, tens is bit 4:6
	//This function gets the amount of tens and ones
	uint8_t tens, ones,binary;
	tens = (value >>4);
	ones = (value & 0x0F);
	binary = tens*10 + ones;

	return (uint8_t)binary;
}



uint8_t  I2C_RXTX_Start(uint8_t * pTXBuffer, uint32_t Len, uint8_t sr,uint8_t RXTX,uint8_t value,uint8_t reg_addr)
{
	//Check if the state isnt busy recieving or transmitting
	if( (I2C_state != I2C_BUSY_IN_TX) && (I2C_state != I2C_BUSY_IN_RX))
	{
		tx[0]=reg_addr;
			tx[1] = value;
		//Set the I2C state and other global vars
		I2C_state = RXTX;
		pBuffer = pTXBuffer;
		len = Len;
		repeatedStart = sr;

		if(I2C_state == I2C_BUSY_IN_RX)
		{
			//Addtionally acking should be enabled if recieving
			I2C1->CR1 |= (1<< 10);
		}


		//Generate START Condition
		I2C1->CR1 |= (1<< 8);

		//Implement the code to enable ITBUFEN Control Bit
		I2C1->CR2 |= ( 1 << 10);

		//Implement the code to enable ITEVFEN Control Bit
		I2C1->CR2 |= ( 1 << 9);

		//Implement the code to enable ITERREN Control Bit
		I2C1->CR2 |= ( 1 << 8);

		return I2C_READY;


	}
	return I2C_state;
}

static void ds1307_write(uint8_t value,uint8_t reg_addr)
{
	//Sends two bytes of data to enable the clock


	while(I2C_RXTX_Start(tx, 2, 0,I2C_BUSY_IN_TX,value,reg_addr) != I2C_READY);
}

void ds1307_read(uint8_t reg_addr)
{

	//Data will be read from current position of pointer so data write is used to set pointer position
	while(I2C_RXTX_Start(&reg_addr, 1, 1,I2C_BUSY_IN_TX,0,0)  != I2C_READY);
	while(I2C_RXTX_Start(&data, 1, 0,I2C_BUSY_IN_RX,0,0) != I2C_READY);

}

#define NVIC_ISER0		0xE000E100
#define NVIC_ISER1		0xE000E104



void ds1307_set_current_date(RTC_date_t * rtc_date)
{
	ds1307_write(binary_to_bcd(rtc_date->date), DS1307_ADDR_DATE);
	ds1307_write(binary_to_bcd(rtc_date->year), DS1307_ADDR_YEAR);
	ds1307_write(binary_to_bcd(rtc_date->month), DS1307_ADDR_MONTH);
	ds1307_write(binary_to_bcd(rtc_date->day), DS1307_ADDR_DAY);
}
void ds1307_get_current_date(RTC_date_t * rtc_date)
{
	ds1307_read(DS1307_ADDR_DATE);
	rtc_date->date = bcd_to_binary(*pBuffer);
	ds1307_read(DS1307_ADDR_YEAR);
	rtc_date->year = bcd_to_binary(*pBuffer);
	ds1307_read(DS1307_ADDR_MONTH);
	rtc_date->month = bcd_to_binary(*pBuffer);
	ds1307_read(DS1307_ADDR_DAY);
	rtc_date->day = bcd_to_binary(*pBuffer);
}


void ds1307_set_current_time(RTC_time_t *rtc_time)
{
	uint8_t seconds, hrs;
	seconds = binary_to_bcd(rtc_time->seconds);
	//Ensure bit 7 is cleared to not turn of clock
	seconds &= ~(1<<7);
	ds1307_write(seconds,DS1307_ADDR_SEC);

	//send minutes
	ds1307_write(binary_to_bcd(rtc_time->minutes),DS1307_ADDR_MIN);

	//set hours
	hrs = binary_to_bcd(rtc_time->hours);
	//Ensure bit 7 is cleared to not turn of clock
	if(rtc_time->time_format == TIME_FORMAT_24HRS)
	{
		hrs &= ~(1 << 6);
	}
	else
	{
		hrs |= (1 << 6);
		hrs =(rtc_time->time_format ==TIME_FORMAT_12HRS_PM ) ? hrs | (1<<5) : hrs & ~(1<<5);
	}
	ds1307_write(hrs,DS1307_ADDR_HRS);
}
void ds1307_get_current_time(RTC_time_t *rtc_time)
{
	uint8_t seconds,hrs;
	ds1307_read(DS1307_ADDR_SEC);
	seconds = *pBuffer;
	seconds &= ~(1 << 7);

	rtc_time->seconds = bcd_to_binary(seconds);
	ds1307_read(DS1307_ADDR_MIN);
	rtc_time->minutes = bcd_to_binary(*pBuffer);

	ds1307_read(DS1307_ADDR_HRS);
	hrs = *pBuffer;
	if(hrs & (1<<6))
	{
		//12hr format
		//ever gives 12hr am (0) or 12hr pm (1)
		rtc_time->time_format = !((hrs & (1<< 5)) == 0) ;
		//clear 6th and 5th position
		hrs &= ~(0x3 << 5);
	}
	else
	{
		//24hrs format
		rtc_time->time_format = TIME_FORMAT_24HRS;
	}

	rtc_time->hours = bcd_to_binary(hrs);
}

RTC_time_t current_time;
RTC_date_t current_date;
int main(void)
{


    /* Loop forever */
	uint32_t *RCC_APB2ENR = (uint32_t *)(0x40021018);
	uint32_t *RCC_APB1ENR = (uint32_t *)(0x4002101C);


	//Enable clock on GPIOA, GPIOB and I2C1
	*RCC_APB2ENR |= (1 << 2);
	*RCC_APB2ENR |= (1 << 3);
	*RCC_APB1ENR |= (1<< 21);


	//Enable interupts for I2C for both event and error I2C 38 & 39
	*((uint32_t*)NVIC_ISER0) |= 1<<31;
	*((uint32_t*)NVIC_ISER1) |= 1<<0;

	//Set the GPIOA ports to work for LEDS
	uint32_t temp = 0;
	temp |= (1<< 0);
	temp |= (1<< 4);
	temp |= (1<< 8);
	temp |= (1<< 12);
	temp |= (1<< 16);
	temp |= (1<< 20);
	temp |= (1<< 24);
	GPIOA->CRL = temp;



	//Configure the pins B8 and B9 for I2C -> both need to be AF and open drain value of 1101
	GPIOB->CRL &= ~(0xF << 24);
	GPIOB->CRL |= (0xD << 24);
	GPIOB->CRL &= ~(0xF << 28);
	GPIOB->CRL |= (0xD << 28);


	//Set the frequency of clock provided to cr2
	I2C1->CR2 |= ((HSI_SPEED/1000000));


	//Configure the device address will maybe do
	I2C1->OAR1 |= (0x61 << 1);

	//The 14th bit of the OAR1 register must always be mainted by software as 1
	I2C1->OAR1 |= (1<<14);

	//Set the CCR
	I2C1->CCR |= ((HSI_SPEED / (2*I2C_SCL_SPEED_SM)));

	//Set the trise value
	I2C1->TRISE =(((HSI_SPEED / 1000000) + 1) & 0x3F);

	//Enable the I2C
	I2C1->CR1 |= 1;



	//Make clock halt = 0 in DS peripheal
	ds1307_write(0x0, DS1307_ADDR_SEC);





	current_date.day = FRIDAY;
	current_date.date = 18;
	current_date.month = 1;
	current_date.year = 19;
	current_time.seconds = 34;
	current_time.hours = 8;
	current_time.minutes = 42;
	current_time.time_format = TIME_FORMAT_12HRS_PM;

	ds1307_set_current_date(&current_date);

	for(int k = 0; k <5000000; k++)
	{
		;
	}
	//ds1307_get_current_time(&current_time);
	ds1307_get_current_date(&current_date);
	while(1);





//	while(1)
//	{
//		//
//
//	}

}

void I2C1_EV_IRQHandler(void)
{
	//SB bit set
	if(I2C1->SR1 & 1)
	{
		//SB bit cleared by wirting slave address to DR

		//In case of TX
		 if(I2C_state == I2C_BUSY_IN_TX)
		 {
			//As writing bit 0 must be cleared
			I2C1->DR = ((DS1307_DEVICE_ADDR << 1) & ~1);
		 }
		 else
		 {
			 I2C1->DR = ((DS1307_DEVICE_ADDR << 1)  | 1);
		 }

	}


	//ADDR flag set
	 if(I2C1->SR1& (1<< 1))
	 {
		 //ADDR flag cleared by reading SR1 then SR2
		//Write first byte of data
		 uint32_t dummyread;
		 dummyread = I2C1->SR1;
		 dummyread = I2C1->SR2;
		 (void)dummyread;


		 //In case of RX
		 if(I2C_state == I2C_BUSY_IN_RX)
		 {
			 //ACKING MUST BE DISABLED HERE IN CASE
			 I2C1->CR1 &= ~(1<< 10);
			 //Generate stop condition
			 I2C1->CR1 |= (1<< 9);
		 }

	 }

	 //BTF set close communication
	 if(I2C1->SR1& (1<< 2))
	 {
		 //TXE should also be set
		 if(I2C1->SR1& (1<< 7))
		 {
			 //Len should also equal 0
			 if(len == 0)
			 {
				 //Generate the stop conidtion
				 I2C1->CR1 |= (1<< 9);

				 //Disable the interupts
				 //Implement the code to enable ITBUFEN Control Bit
				I2C1->CR2 &= ~( 1 << 10);

				//Implement the code to enable ITEVFEN Control Bit
				I2C1->CR2 &= ~( 1 << 9);

				//Implement the code to enable ITERREN Control Bit
				I2C1->CR2 &= ~( 1 << 8);

				I2C_state= I2C_READY;
			 }
		 }
	 }

	//TXE set
	if(I2C1->SR1& (1<< 7))
	{
		//write data into DR
		if(len > 0)
		{
			//1. load the data in to DR
			I2C1->DR = *(pBuffer);

			//2. decrement the TxLen
			len--;

			//3. Increment the buffer address
			pBuffer++;

		}
	}

	//RXNE set
	if(I2C1->SR1& (1<< 6))
	{
		//End of event

		//Read the data from the data register to clear the RXNE flag
		*pBuffer = I2C1->DR;
		//Implement the code to enable ITBUFEN Control Bit
						I2C1->CR2 &= ~( 1 << 10);

						//Implement the code to enable ITEVFEN Control Bit
						I2C1->CR2 &= ~( 1 << 9);

						//Implement the code to enable ITERREN Control Bit
						I2C1->CR2 &= ~( 1 << 8);

						I2C_state= I2C_READY;


	}


}

void I2C1_ER_IRQHandler(void)
{

}






